// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file events_service.proto (package events, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file events_service.proto.
 */
export const file_events_service: GenFile = /*@__PURE__*/
  fileDesc("ChRldmVudHNfc2VydmljZS5wcm90bxIGZXZlbnRzIo8DCg1FdmVudHNSZXF1ZXN0Eg8KB3NvdXJjZXMYASADKAkSEgoKY2F0ZWdvcmllcxgCIAMoCRIjCgZzdGF0dXMYAyABKA4yEy5ldmVudHMuRXZlbnRTdGF0dXMSEgoFbGltaXQYBCABKAVIAIgBARIXCgpkYXlzX3ByaW9yGAUgASgFSAGIAQESLgoFc3RhcnQYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAKIAQESLAoDZW5kGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgDiAEBEi8KCW1hZ25pdHVkZRgIIAEoCzIXLmV2ZW50cy5NYWduaXR1ZGVGaWx0ZXJIBIgBARIuCgxib3VuZGluZ19ib3gYCSABKAsyEy5ldmVudHMuQm91bmRpbmdCb3hIBYgBAUIICgZfbGltaXRCDQoLX2RheXNfcHJpb3JCCAoGX3N0YXJ0QgYKBF9lbmRCDAoKX21hZ25pdHVkZUIPCg1fYm91bmRpbmdfYm94IjwKDkV2ZW50c1Jlc3BvbnNlEh0KBmV2ZW50cxgBIAMoCzINLmV2ZW50cy5FdmVudBILCgN1cmwYAiABKAkiFgoURXZlbnRzQ29udGV4dFJlcXVlc3QipAEKFUV2ZW50c0NvbnRleHRSZXNwb25zZRIkCgpjYXRlZ29yaWVzGAEgAygLMhAuZXZlbnRzLkNhdGVnb3J5Eh0KBmxheWVycxgCIAMoCzINLmV2ZW50cy5MYXllchIfCgdzb3VyY2VzGAMgAygLMg4uZXZlbnRzLlNvdXJjZRIlCgptYWduaXR1ZGVzGAQgAygLMhEuZXZlbnRzLk1hZ25pdHVkZSJRCg9NYWduaXR1ZGVGaWx0ZXISCgoCaWQYASABKAkSEAoDbWluGAIgASgBSACIAQESEAoDbWF4GAMgASgBSAGIAQFCBgoEX21pbkIGCgRfbWF4ImcKC0JvdW5kaW5nQm94EhUKDW1pbl9sb25naXR1ZGUYASABKAESFAoMbWF4X2xhdGl0dWRlGAIgASgBEhUKDW1heF9sb25naXR1ZGUYAyABKAESFAoMbWluX2xhdGl0dWRlGAQgASgBIssCCgVFdmVudBIKCgJpZBgBIAEoCRINCgV0aXRsZRgCIAEoCRIYCgtkZXNjcmlwdGlvbhgDIAEoCUgAiAEBEgsKA3VybBgEIAEoCRIuCgpzdGFydF9kYXRlGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI0CgtjbG9zZWRfZGF0ZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIAYgBARIpCgpjYXRlZ29yaWVzGAcgAygLMhUuZXZlbnRzLkV2ZW50Q2F0ZWdvcnkSJAoHc291cmNlcxgIIAMoCzITLmV2ZW50cy5FdmVudFNvdXJjZRIpCgpnZW9tZXRyaWVzGAkgAygLMhUuZXZlbnRzLkV2ZW50R2VvbWV0cnlCDgoMX2Rlc2NyaXB0aW9uQg4KDF9jbG9zZWRfZGF0ZSIqCg1FdmVudENhdGVnb3J5EgoKAmlkGAEgASgJEg0KBXRpdGxlGAIgASgJIjwKC0V2ZW50U291cmNlEgoKAmlkGAEgASgJEiEKGWV4dGVybmFsX3NvdXJjZV9ldmVudF91cmwYAiABKAkiuwIKDUV2ZW50R2VvbWV0cnkSKAoEZGF0ZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASJwoEdHlwZRgDIAEoDjIZLmV2ZW50cy5FdmVudEdlb21ldHJ5VHlwZRInCgVwb2ludBgEIAEoCzITLmV2ZW50cy5Db29yZGluYXRlc0gAiAEBEiQKB3BvbHlnb24YBSADKAsyEy5ldmVudHMuUG9seWdvbkxpbmUSGwoObWFnbml0dWRlX3VuaXQYBiABKAlIAYgBARI6Cg9tYWduaXR1ZGVfdmFsdWUYByABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVIAogBAUIICgZfcG9pbnRCEQoPX21hZ25pdHVkZV91bml0QhIKEF9tYWduaXR1ZGVfdmFsdWUiMAoLUG9seWdvbkxpbmUSIQoEbGluZRgBIAMoCzITLmV2ZW50cy5Db29yZGluYXRlcyJWCgtDb29yZGluYXRlcxIQCghsYXRpdHVkZRgBIAEoARIRCglsb25naXR1ZGUYAiABKAESFQoIYWx0aXR1ZGUYAyABKAFIAIgBAUILCglfYWx0aXR1ZGUiawoIQ2F0ZWdvcnkSCgoCaWQYASABKAkSDQoFdGl0bGUYAiABKAkSEwoLZGVzY3JpcHRpb24YAyABKAkSCwoDdXJsGAQgASgJEhIKCmxheWVyc191cmwYBSABKAkSDgoGbGF5ZXJzGAYgAygJIpMBCgVMYXllchIKCgJpZBgBIAEoCRITCgtzZXJ2aWNlX3VybBgCIAEoCRIXCg9zZXJ2aWNlX3R5cGVfaWQYAyABKAkSEwoGZm9ybWF0GAQgASgJSACIAQESHAoPdGlsZV9tYXRyaXhfc2V0GAUgASgJSAGIAQFCCQoHX2Zvcm1hdEISChBfdGlsZV9tYXRyaXhfc2V0IksKBlNvdXJjZRIKCgJpZBgBIAEoCRINCgV0aXRsZRgCIAEoCRISCgpzb3VyY2VfdXJsGAMgASgJEhIKCmV2ZW50c191cmwYBCABKAkiXQoJTWFnbml0dWRlEgoKAmlkGAEgASgJEg0KBXRpdGxlGAIgASgJEgwKBHVuaXQYAyABKAkSEwoLZGVzY3JpcHRpb24YBCABKAkSEgoKZXZlbnRzX3VybBgFIAEoCSosCgtFdmVudFN0YXR1cxIICgRPUEVOEAASCgoGQ0xPU0VEEAESBwoDQUxMEAIqKwoRRXZlbnRHZW9tZXRyeVR5cGUSCQoFUE9JTlQQABILCgdQT0xZR09OEAEynAEKDUV2ZW50c1NlcnZpY2USOgoJR2V0RXZlbnRzEhUuZXZlbnRzLkV2ZW50c1JlcXVlc3QaFi5ldmVudHMuRXZlbnRzUmVzcG9uc2USTwoQR2V0RXZlbnRzQ29udGV4dBIcLmV2ZW50cy5FdmVudHNDb250ZXh0UmVxdWVzdBodLmV2ZW50cy5FdmVudHNDb250ZXh0UmVzcG9uc2VCGaoCFkVvbmV0Vmlld2VyLkFwaS5Qcm90b3NiBnByb3RvMw", [file_google_protobuf_timestamp, file_google_protobuf_wrappers]);

/**
 * Represents filters for querying events from the EONET API.
 *
 * @generated from message events.EventsRequest
 */
export type EventsRequest = Message<"events.EventsRequest"> & {
  /**
   * Filter by event sources, none - means all sources.
   *
   * @generated from field: repeated string sources = 1;
   */
  sources: string[];

  /**
   * Filter by event categories, none - means all categories.
   *
   * @generated from field: repeated string categories = 2;
   */
  categories: string[];

  /**
   * Filter based on events having a closed date.
   *
   * @generated from field: events.EventStatus status = 3;
   */
  status: EventStatus;

  /**
   * Limits the number of events returned.
   *
   * @generated from field: optional int32 limit = 4;
   */
  limit?: number;

  /**
   * Limit the number of the days prior (including today) from which events will be returned.
   *
   * @generated from field: optional int32 days_prior = 5;
   */
  daysPrior?: number;

  /**
   * Min date of events.
   *
   * @generated from field: optional google.protobuf.Timestamp start = 6;
   */
  start?: Timestamp;

  /**
   * Max date of events.
   *
   * @generated from field: optional google.protobuf.Timestamp end = 7;
   */
  end?: Timestamp;

  /**
   * A ceiling, floor, or range of magnitude values for the events.
   *
   * @generated from field: optional events.MagnitudeFilter magnitude = 8;
   */
  magnitude?: MagnitudeFilter;

  /**
   * A bounding box for event coordinates to fall into.
   *
   * @generated from field: optional events.BoundingBox bounding_box = 9;
   */
  boundingBox?: BoundingBox;
};

/**
 * Describes the message events.EventsRequest.
 * Use `create(EventsRequestSchema)` to create a new message.
 */
export const EventsRequestSchema: GenMessage<EventsRequest> = /*@__PURE__*/
  messageDesc(file_events_service, 0);

/**
 * Response containing natural events.
 *
 * @generated from message events.EventsResponse
 */
export type EventsResponse = Message<"events.EventsResponse"> & {
  /**
   * A list of natural events.
   *
   * @generated from field: repeated events.Event events = 1;
   */
  events: Event[];

  /**
   * A url used to retrieve the data from EONET.
   *
   * @generated from field: string url = 2;
   */
  url: string;
};

/**
 * Describes the message events.EventsResponse.
 * Use `create(EventsResponseSchema)` to create a new message.
 */
export const EventsResponseSchema: GenMessage<EventsResponse> = /*@__PURE__*/
  messageDesc(file_events_service, 1);

/**
 * @generated from message events.EventsContextRequest
 */
export type EventsContextRequest = Message<"events.EventsContextRequest"> & {
};

/**
 * Describes the message events.EventsContextRequest.
 * Use `create(EventsContextRequestSchema)` to create a new message.
 */
export const EventsContextRequestSchema: GenMessage<EventsContextRequest> = /*@__PURE__*/
  messageDesc(file_events_service, 2);

/**
 * @generated from message events.EventsContextResponse
 */
export type EventsContextResponse = Message<"events.EventsContextResponse"> & {
  /**
   * @generated from field: repeated events.Category categories = 1;
   */
  categories: Category[];

  /**
   * @generated from field: repeated events.Layer layers = 2;
   */
  layers: Layer[];

  /**
   * @generated from field: repeated events.Source sources = 3;
   */
  sources: Source[];

  /**
   * @generated from field: repeated events.Magnitude magnitudes = 4;
   */
  magnitudes: Magnitude[];
};

/**
 * Describes the message events.EventsContextResponse.
 * Use `create(EventsContextResponseSchema)` to create a new message.
 */
export const EventsContextResponseSchema: GenMessage<EventsContextResponse> = /*@__PURE__*/
  messageDesc(file_events_service, 3);

/**
 * Ceiling, floor, or range of magnitude values for the events to fall between (inclusive).
 *
 * @generated from message events.MagnitudeFilter
 */
export type MagnitudeFilter = Message<"events.MagnitudeFilter"> & {
  /**
   * Unique id of magnitude unit.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Optional min magnitude value.
   *
   * @generated from field: optional double min = 2;
   */
  min?: number;

  /**
   * Optional min magnitude value.
   *
   * @generated from field: optional double max = 3;
   */
  max?: number;
};

/**
 * Describes the message events.MagnitudeFilter.
 * Use `create(MagnitudeFilterSchema)` to create a new message.
 */
export const MagnitudeFilterSchema: GenMessage<MagnitudeFilter> = /*@__PURE__*/
  messageDesc(file_events_service, 4);

/**
 * Bounding box to filter events by coordinates.
 *
 * @generated from message events.BoundingBox
 */
export type BoundingBox = Message<"events.BoundingBox"> & {
  /**
   * Minimum longitude (left boundary).
   *
   * @generated from field: double min_longitude = 1;
   */
  minLongitude: number;

  /**
   * Maximum latitude (top boundary).
   *
   * @generated from field: double max_latitude = 2;
   */
  maxLatitude: number;

  /**
   * Maximum longitude (right boundary).
   *
   * @generated from field: double max_longitude = 3;
   */
  maxLongitude: number;

  /**
   * Minimum latitude (bottom boundary).
   *
   * @generated from field: double min_latitude = 4;
   */
  minLatitude: number;
};

/**
 * Describes the message events.BoundingBox.
 * Use `create(BoundingBoxSchema)` to create a new message.
 */
export const BoundingBoxSchema: GenMessage<BoundingBox> = /*@__PURE__*/
  messageDesc(file_events_service, 5);

/**
 * Natural event.
 *
 * @generated from message events.Event
 */
export type Event = Message<"events.Event"> & {
  /**
   * Unique event id.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Title of the event.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * Optional longer description of the event. Most likely only a sentence or two.
   *
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * Full url to the API endpoint for this specific event.
   *
   * @generated from field: string url = 4;
   */
  url: string;

  /**
   * @generated from field: google.protobuf.Timestamp start_date = 5;
   */
  startDate?: Timestamp;

  /**
   * Event is deemed �closed� when it has ended. The closed field will include a date/time when the event has ended. Depending upon the nature of the event, the closed value may or may not accurately represent the absolute ending of the event. If the event is open, this will show �null�.
   *
   * @generated from field: optional google.protobuf.Timestamp closed_date = 6;
   */
  closedDate?: Timestamp;

  /**
   * One or more categories assigned to the event.
   *
   * @generated from field: repeated events.EventCategory categories = 7;
   */
  categories: EventCategory[];

  /**
   * One or more sources that refer to more information about the event.
   *
   * @generated from field: repeated events.EventSource sources = 8;
   */
  sources: EventSource[];

  /**
   * One or more event geometries are the pairing of a specific date/time with a location. The date/time will most likely be 00:00Z unless the source provided a particular time. The geometry will be a GeoJSON object of either type �Point� or �Polygon�.
   *
   * @generated from field: repeated events.EventGeometry geometries = 9;
   */
  geometries: EventGeometry[];
};

/**
 * Describes the message events.Event.
 * Use `create(EventSchema)` to create a new message.
 */
export const EventSchema: GenMessage<Event> = /*@__PURE__*/
  messageDesc(file_events_service, 6);

/**
 * Mapping from a natural event to a category.
 *
 * @generated from message events.EventCategory
 */
export type EventCategory = Message<"events.EventCategory"> & {
  /**
   * Unique category id.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Title of the category.
   *
   * @generated from field: string title = 2;
   */
  title: string;
};

/**
 * Describes the message events.EventCategory.
 * Use `create(EventCategorySchema)` to create a new message.
 */
export const EventCategorySchema: GenMessage<EventCategory> = /*@__PURE__*/
  messageDesc(file_events_service, 7);

/**
 * Mapping from a natural event to a source.
 *
 * @generated from message events.EventSource
 */
export type EventSource = Message<"events.EventSource"> & {
  /**
   * Unique source id.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Url of this specific event in the original source.
   *
   * @generated from field: string external_source_event_url = 2;
   */
  externalSourceEventUrl: string;
};

/**
 * Describes the message events.EventSource.
 * Use `create(EventSourceSchema)` to create a new message.
 */
export const EventSourceSchema: GenMessage<EventSource> = /*@__PURE__*/
  messageDesc(file_events_service, 8);

/**
 * Geometry of a natural event.
 *
 * @generated from message events.EventGeometry
 */
export type EventGeometry = Message<"events.EventGeometry"> & {
  /**
   * Date and time of the event.
   *
   * @generated from field: google.protobuf.Timestamp date = 1;
   */
  date?: Timestamp;

  /**
   * Type of geometry, Point or Polygon.
   *
   * @generated from field: events.EventGeometryType type = 3;
   */
  type: EventGeometryType;

  /**
   * Event point coordinates, available only for Point type.
   *
   * @generated from field: optional events.Coordinates point = 4;
   */
  point?: Coordinates;

  /**
   * Event polygon coordinates, available only for Polygon type.
   *
   * @generated from field: repeated events.PolygonLine polygon = 5;
   */
  polygon: PolygonLine[];

  /**
   * Unit of the magnitude value.
   *
   * @generated from field: optional string magnitude_unit = 6;
   */
  magnitudeUnit?: string;

  /**
   * Magnitude value of the event.
   *
   * @generated from field: optional google.protobuf.DoubleValue magnitude_value = 7;
   */
  magnitudeValue?: number;
};

/**
 * Describes the message events.EventGeometry.
 * Use `create(EventGeometrySchema)` to create a new message.
 */
export const EventGeometrySchema: GenMessage<EventGeometry> = /*@__PURE__*/
  messageDesc(file_events_service, 9);

/**
 * Closed line representing polygon limits.
 *
 * @generated from message events.PolygonLine
 */
export type PolygonLine = Message<"events.PolygonLine"> & {
  /**
   * Coordinates of the polygon line.
   *
   * @generated from field: repeated events.Coordinates line = 1;
   */
  line: Coordinates[];
};

/**
 * Describes the message events.PolygonLine.
 * Use `create(PolygonLineSchema)` to create a new message.
 */
export const PolygonLineSchema: GenMessage<PolygonLine> = /*@__PURE__*/
  messageDesc(file_events_service, 10);

/**
 * Position of event geometry
 *
 * @generated from message events.Coordinates
 */
export type Coordinates = Message<"events.Coordinates"> & {
  /**
   * Latitude of the position.
   *
   * @generated from field: double latitude = 1;
   */
  latitude: number;

  /**
   * Longitude of the position.
   *
   * @generated from field: double longitude = 2;
   */
  longitude: number;

  /**
   * Altitude of the position.
   *
   * @generated from field: optional double altitude = 3;
   */
  altitude?: number;
};

/**
 * Describes the message events.Coordinates.
 * Use `create(CoordinatesSchema)` to create a new message.
 */
export const CoordinatesSchema: GenMessage<Coordinates> = /*@__PURE__*/
  messageDesc(file_events_service, 11);

/**
 * @generated from message events.Category
 */
export type Category = Message<"events.Category"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * @generated from field: string url = 4;
   */
  url: string;

  /**
   * @generated from field: string layers_url = 5;
   */
  layersUrl: string;

  /**
   * @generated from field: repeated string layers = 6;
   */
  layers: string[];
};

/**
 * Describes the message events.Category.
 * Use `create(CategorySchema)` to create a new message.
 */
export const CategorySchema: GenMessage<Category> = /*@__PURE__*/
  messageDesc(file_events_service, 12);

/**
 * @generated from message events.Layer
 */
export type Layer = Message<"events.Layer"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string service_url = 2;
   */
  serviceUrl: string;

  /**
   * @generated from field: string service_type_id = 3;
   */
  serviceTypeId: string;

  /**
   * @generated from field: optional string format = 4;
   */
  format?: string;

  /**
   * @generated from field: optional string tile_matrix_set = 5;
   */
  tileMatrixSet?: string;
};

/**
 * Describes the message events.Layer.
 * Use `create(LayerSchema)` to create a new message.
 */
export const LayerSchema: GenMessage<Layer> = /*@__PURE__*/
  messageDesc(file_events_service, 13);

/**
 * @generated from message events.Source
 */
export type Source = Message<"events.Source"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string source_url = 3;
   */
  sourceUrl: string;

  /**
   * @generated from field: string events_url = 4;
   */
  eventsUrl: string;
};

/**
 * Describes the message events.Source.
 * Use `create(SourceSchema)` to create a new message.
 */
export const SourceSchema: GenMessage<Source> = /*@__PURE__*/
  messageDesc(file_events_service, 14);

/**
 * @generated from message events.Magnitude
 */
export type Magnitude = Message<"events.Magnitude"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string unit = 3;
   */
  unit: string;

  /**
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * @generated from field: string events_url = 5;
   */
  eventsUrl: string;
};

/**
 * Describes the message events.Magnitude.
 * Use `create(MagnitudeSchema)` to create a new message.
 */
export const MagnitudeSchema: GenMessage<Magnitude> = /*@__PURE__*/
  messageDesc(file_events_service, 15);

/**
 * Filter based on events having a closed date.
 *
 * @generated from enum events.EventStatus
 */
export enum EventStatus {
  /**
   * Events have no closed date.
   *
   * @generated from enum value: OPEN = 0;
   */
  OPEN = 0,

  /**
   * Events have a closed date.
   *
   * @generated from enum value: CLOSED = 1;
   */
  CLOSED = 1,

  /**
   * All events, regardless of having a closed date or not.
   *
   * @generated from enum value: ALL = 2;
   */
  ALL = 2,
}

/**
 * Describes the enum events.EventStatus.
 */
export const EventStatusSchema: GenEnum<EventStatus> = /*@__PURE__*/
  enumDesc(file_events_service, 0);

/**
 * Event geometry types.
 *
 * @generated from enum events.EventGeometryType
 */
export enum EventGeometryType {
  /**
   * Point geometry type.
   *
   * @generated from enum value: POINT = 0;
   */
  POINT = 0,

  /**
   * Polygon geometry type.
   *
   * @generated from enum value: POLYGON = 1;
   */
  POLYGON = 1,
}

/**
 * Describes the enum events.EventGeometryType.
 */
export const EventGeometryTypeSchema: GenEnum<EventGeometryType> = /*@__PURE__*/
  enumDesc(file_events_service, 1);

/**
 * The events service definition.
 *
 * @generated from service events.EventsService
 */
export const EventsService: GenService<{
  /**
   * Gets events based on the provided filters.
   *
   * @generated from rpc events.EventsService.GetEvents
   */
  getEvents: {
    methodKind: "unary";
    input: typeof EventsRequestSchema;
    output: typeof EventsResponseSchema;
  },
  /**
   * @generated from rpc events.EventsService.GetEventsContext
   */
  getEventsContext: {
    methodKind: "unary";
    input: typeof EventsContextRequestSchema;
    output: typeof EventsContextResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_events_service, 0);

